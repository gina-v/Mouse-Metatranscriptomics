---
title: "Differential Gene Expression of *Salmonella enterica subsp. enterica* serovar Typhimurium"
author: "Gina Vazquez"
date: "2023-11-09"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo=FALSE, include=FALSE}
library(SummarizedExperiment)
library(tximeta)
library(DESeq2)
library(dplyr)
library(ggplot2)
library(readr)
library(pheatmap)
library(tidyverse)
library(IHW)
library(ashr)
library(ggplot2)
library("RColorBrewer")
library(ggrepel)
```

## Project Overview

The primary carbon source for anaerobic bacteria in the large intestine are complex glycans. Bacteria of the Bacteroidetes and Firmicutes phyla encompass the majority of the gut microbiota. Bacterial genomes from these phyla encode for various types of glycan degradation genes. The ability to degrade a variety of complex carbohydrates has been found to directly correlate with species abundance in the gut. Proteobacteria, such as *Salmonella enterica subsp. enterica* serovar Typhimurium, express a very limited amount of genes associated with glycan degradation suggesting that the mechanisms for gut colonization must be different from the glycan-foraging mechanisms used by native gut microbiota. Here, I will investigate what genes are differentially expressed in S. Tm in a defined minimal community of native microbiota in murine samples.

## Project Outline
Here I am comparing the gene expression of *Salmonella enterica subsp. enterica* serovar Typhimurium in two groups. Samples 279.1 - 279.5 are biological replicates of a mouse gut (GRCm39) inoculated with *Salmonella enterica subsp. enterica* serovar Typhimurium. Samples 278.1 - 278.5 are biological replicates of a mouse gut (GRCm39) inoculated with *Clostridium symbiosum, Bacteroides thetaiotaomicron VPI-5482*, and *Salmonella enterica subsp. enterica* serovar Typhimurium. 

The sequencing data used in this analysis are from two published papers by Sebastian Winter's lab. Note that mouse microbiome samples for [Zhu et al., 2020](https://pubmed.ncbi.nlm.nih.gov/32075741/) and [Spiga et al., 2017](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5599368/) were collected and processed at the same time. These data are not all publicly available through ENA hence why the naming convention of the samples are not tied to corresponding accession numbers. The data were acquired from the lab's box link and I kept the original, in-lab naming convention. When possible, the names of the samples will be matched to the GenBank/ENA accession numbers for public availability.

## Metatranscriptomics Summary

### Snakemake Workflow

(1) Rule fastp

The fastq of the aforementioned ten samples were obtained from a raw data spreadsheet stored in a Box account held by Sebastian Winter's lab. Fastp was used to trim adapters, bases with a quality phred-score lower than 4, and reads shorter than 31 bp in length. It also performed base corrections during trimming. A fastq file, json file, and html file were produced for each sample.

(2) Rule filter_mouse_reads

Bowtie2 was used to align the trimmed fastq files generated by the fastp rule to the index files of the mouse genome ([GRCm39](https://www.ncbi.nlm.nih.gov/datasets/genome/GCF_000001635.27/)). The index files for the mouse genome were made outside the Snakemake workflow. Reads that did not align to the mouse genome were saved as filtered fastq files.

(3) Rule align_to_microbe

Bowtie2 was used to align the filtered fastq files generated by rule filter_mouse_reads to the index files for the [*Salmonella enterica subsp. enterica* serovar Typhimurium genome](https://www.ncbi.nlm.nih.gov/datasets/genome/GCF_000743055.1/). The index files for the microbial genome were made outside the Snakemake workflow. Reads aligning to the microbial genome were saved as a sam file.

(4) Rule convert_sam_to_sorted_bam

Samtools was used to convert sam files generated by rule align_to_microbe to sorted bam files.

(5) FeatureCounts was used to count transcripts that mapped to the microbial genome from the sorted bam files generated by the convert_sam_to_sorted_bam rule. It was not written as a rule in the Snakemake file because of issues with the variables. The FeatureCounts command is noted as a comment in the Snakemake file.

### Future Notes

An alternative approach:

-   Make a "master reference genome" containing all the reference genomes relevant to all samples.
-   Generate index files from the master reference genome.
-   Align all samples to these index files.
-   Generate FeatureCounts table of all reads that mapped.

Deseq2 calculates library size to determine the scaling factor for each sample based on the FeatureCounts table. Creating a FeatureCounts table with all aligned reads would retain the true library size which could effect the differential gene expression results.

**Note** Hannah has made a workflow with these updates. I will update this document with a summary of the workflow and effects on DGE results.  

## Deseq2 Workflow

### Read in FeatureCounts Table

```{r}
# The gene_name column cannot be the row names because there are repeat names 
df_stm_fc = read.delim("stm_1110.txt", skip = 1, header = TRUE, row.names = 1, stringsAsFactors = FALSE)
df_stm = df_stm_fc[c("X278.1_stm.sorted.bam",	"X278.2_stm.sorted.bam",	"X278.3_stm.sorted.bam",	"X278.4_stm.sorted.bam",	"X278.5_stm.sorted.bam",	"X279.1_stm.sorted.bam",	"X279.2_stm.sorted.bam",	"X279.3_stm.sorted.bam",	"X279.4_stm.sorted.bam",	"X279.5_stm.sorted.bam")]

head(df_stm_fc)
```

### Make the DeSeq2 object

The samples and conditions are saved in 'exp_stm.csv'. The FeatureCounts data frame and experimental design CSV are used to make the DeSeq2 object.
```{r, warning=FALSE}
csv_exp_stm = read.csv("exp_stm.csv")
print(csv_exp_stm)

dds_stm = DESeqDataSetFromMatrix(countData = df_stm, colData = csv_exp_stm, design = ~ condition)
```

## Results
### Differential Gene Expression

```{r, message=FALSE}
# Set factor levels
dds_stm$condition = factor(dds_stm$condition, levels = c("stm","cs/bt/stm"))

# DeSeq2 results 
dds_stm = DESeq(dds_stm)
stm_res = results(dds_stm)

# Match gene names to results 
stm_res_names <- stm_res
stm_res_names$genenames <- df_stm_fc$gene_name[seq_along(stm_res[, 1])]
head(stm_res_names)
summary(stm_res_names)

# Make a table of DeSeq2 results
write.csv(stm_res_names, file="stm_results.csv")
```

### Sort Results

```{r}
# Sort results by log2 fold change
res_sorted_stm = stm_res_names[order(abs(stm_res_names$log2FoldChange), decreasing = TRUE), ]

# Subset significant results based on adjusted p-value threshold (e.g., 0.05)
significant_genes_stm = subset(res_sorted_stm, padj < 0.05)

# View summary of significant genes
summary(significant_genes_stm)
head(significant_genes_stm)
write.csv(significant_genes_stm, file = "stm_sorted_results.csv")
```

### MA Plot with Apeglm Shrinkage

More information on [MDS shrinkage](https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#moreshrink).
```{r, warning=FALSE, message=FALSE}
# Shrink data
apeglm_stm = lfcShrink(dds_stm, coef="condition_cs.bt.stm_vs_stm", type="apeglm")
head(apeglm_stm)

# Match gene names to results 
ma_stm_names <- as.data.frame(apeglm_stm)
ma_stm_names$genenames <- df_stm_fc$gene_name[seq_along(apeglm_stm[, 1])]

# Save MA Data in table 
write.csv(ma_stm_names, file="stm_ma_results.csv")

# Make ma plot 
ggplot(as.data.frame(ma_stm_names), aes(y = log2FoldChange, x = baseMean)) +
  geom_point(size=0.7) +
  labs(y = "Log2 Fold Change (M)", x = "Average Expression (A)") +
  scale_x_continuous(trans='log10') +
   ylim(c(-2, 2)) +
  ggtitle("MA Plot of STM Set with Shrinkage") +
  geom_text_repel(
    data = subset(ma_stm_names, log2FoldChange > 0.75 | log2FoldChange < -0.75),
   # aes(label = genenames),
    aes(label = ifelse(!is.na(genenames), genenames, rownames(ma_stm_names))),
    box.padding = 0.5,
    point.padding = 0.1,
    segment.color = "grey",
    segment.size = 0.2
  )
```

### Normalization with Variance Stabilized Transformation

The `vst()` function performs variance stabilized transformation on the raw count data while controlling for library size which is necessary for an MDS plot.
```{r}
vsd_stm = vst(dds_stm)
```

### Sample Distances

Sample distances are calculated and used for an MDS plot to compare similarity in counts between samples.
```{r}
# Sample distances
sample_dists_stm = assay(vsd_stm) %>%
  t() %>%
  dist() %>%
  as.matrix()

# MDS values from distance matrix
mds_data_stm = data.frame(cmdscale(sample_dists_stm))
mds_stm = cbind(mds_data_stm, as.data.frame(colData(vsd_stm)))
head(mds_stm)
```

### MDS Plot

```{r}
ggplot(mds_stm, aes(X1, X2, color = condition)) + 
  geom_point(size = 3) +
  theme_minimal()
```

### PCA Plot

```{r}
plotPCA(vsd_stm)
```

### Volcano Plot 

```{r, warning=FALSE}
# Make a copy of the deseq2 results data frame to modify for the plot 
stm_res_vol = data.frame(apeglm_stm)

# Add names
stm_res_vol$genenames <- df_stm_fc$gene_name[seq_along(stm_res_vol[, 1])]

# Add a column of NAs
stm_res_vol$diffexpressed <- "NO"

# If log2Foldchange > 0.6 and pvalue < 0.05, set as "UP" 
stm_res_vol$diffexpressed[stm_res_vol$log2FoldChange > 0.6 & stm_res_vol$pvalue < 0.05] <- "UP"

# If log2Foldchange < -0.6 and pvalue < 0.05, set as "DOWN"
stm_res_vol$diffexpressed[stm_res_vol$log2FoldChange < -0.6 & stm_res_vol$pvalue < 0.05] <- "DOWN"

# Label the volcano plot points
# Create a new column "delabel" to de, that will contain the name of genes differentially expressed (NA in case they are not)
stm_res_vol$delabel <- NA

# Populate the delabel column with values from the genenames column 
stm_res_vol$delabel[stm_res_vol$diffexpressed != "NO"] <- stm_res_vol$genenames[stm_res_vol$diffexpressed != "NO"]

# Save volcano plot data as a table 
write.csv(stm_res_vol, file="stm_vol_results.csv")

ggplot(data=as.data.frame(stm_res_vol), aes(x = log2FoldChange, y = -log10(pvalue), col=diffexpressed, label=delabel)) +
        geom_point(size=0.5) + 
        theme_minimal() +
        geom_text_repel() +
        scale_color_manual(values=c("blue", "black", "red")) +
        geom_vline(xintercept=c(-0.6, 0.6), col="red") +
        geom_hline(yintercept=-log10(0.05), col="red")
```

### HeatMap

```{r}
# transform the raw count data from the DeSeq2 object
stm_ntd <- normTransform(dds_stm)

#shorten the sample names in stm_ntd
colnames(stm_ntd) <- sub("_stm.sorted.bam", "", colnames(stm_ntd))

# extract the top 30 genes with the highest mean expression 
stm_select = order(rowMeans(counts(dds_stm,normalized=TRUE)),
                   decreasing=TRUE)[1:30]

# Create a subset of normalized and transformed data with only the top 30 genes based on mean expression level
heatmap_stm = (assay(stm_ntd)[stm_select,])

# Match gene names to results 
heatmap_stm_names <- as.data.frame(heatmap_stm)
heatmap_stm_names$genenames <- df_stm_fc$gene_name[seq_along(heatmap_stm[, 1])]

# Assuming heatmap_stm_names is your data frame
rownames_to_use <- rownames(heatmap_stm_names)
row_indices <- grepl("^STM", rownames_to_use)

# Replace row names starting with "STM" if the corresponding genenames value is not NA
rownames_to_use[row_indices] <- ifelse(!is.na(heatmap_stm_names$genenames[row_indices]),
                                       heatmap_stm_names$genenames[row_indices],
                                       rownames_to_use[row_indices])
# Save heatmap data as table
write.csv(heatmap_stm_names, file = "stm_heat_results.csv")

# Use pheatmap with the modified row names
pheatmap(heatmap_stm_names[, !colnames(heatmap_stm_names) %in% c("genenames")],
         cluster_rows = TRUE, show_rownames = TRUE, show_colnames = TRUE, cluster_cols = FALSE,
         labels_row = rownames_to_use)
```

### HeatMap of Sample-to-Sample Distances

```{r}
stm_dist = dist(t(assay(vsd_stm)))

stm_dist_matrix = as.matrix(stm_dist)

rownames(stm_dist_matrix) = paste(vsd_stm$condition, vsd_stm$type, sep="-")
colnames(stm_dist_matrix) <- sub("_stm.sorted.bam", "", colnames(stm_ntd))

colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(stm_dist_matrix,
         clustering_distance_rows=stm_dist,
         clustering_distance_cols=stm_dist,
         col=colors)
```

### Additional Resources

Further information on how to use DeSeq2 for metatranscriptomic analysis in R can be found [here](https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#data-quality-assessment-by-sample-clustering-and-visualization).
The link to the repository for this project can be found [here](https://github.com/GinaVazquez/Mouse-Metatranscriptomics).

### Appendix

#### MA Plot of STM group without shrinkage

```{r, warning=FALSE, message=FALSE}
ma_data_stm = data.frame(M = stm_res$log2FoldChange, A = rowMeans(counts(dds_stm, normalized = TRUE)))
ggplot(ma_data_stm, aes(x = A, y = M)) +
  geom_point() +
  labs(y = "Log2 Fold Change (M)", x = "Average Expression (A)") + 
  xlim(c(.1, 1e4)) +
  scale_x_continuous(trans='log10') +
  ggtitle("MA Plot of STM Set")
```
